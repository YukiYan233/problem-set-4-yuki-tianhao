<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Problem Set 4_Yuki_Tianhao</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="pset4_template_files/libs/clipboard/clipboard.min.js"></script>
<script src="pset4_template_files/libs/quarto-html/quarto.js"></script>
<script src="pset4_template_files/libs/quarto-html/popper.min.js"></script>
<script src="pset4_template_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="pset4_template_files/libs/quarto-html/anchor.min.js"></script>
<link href="pset4_template_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="pset4_template_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="pset4_template_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="pset4_template_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="pset4_template_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="pset4_template.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></div>
<main class="content" id="quarto-document-content">
\RecustomVerbatimEnvironment{verbatim}{Verbatim}{
  showspaces = false,
  showtabs = false,
  breaksymbolleft={},
  breaklines
}

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Problem Set 4_Yuki_Tianhao</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><strong>PS4:</strong> Due Sat Nov 2 at 5:00PM Central. Worth 100 points. We use (<code>*</code>) to indicate a problem that we think might be time consuming.</p>
<section id="style-points-10-pts" class="level2">
<h2 class="anchored" data-anchor-id="style-points-10-pts">Style Points (10 pts)</h2>
<p>Please refer to the minilesson on code style <strong><a href="https://uchicago.zoom.us/rec/share/pG_wQ-pHTQrJTmqNn4rcrw5V194M2H2s-2jdy8oVhWHkd_yZt9o162IWurpA-fxU.BIQlSgZLRYctvzp-">here</a></strong>.</p>
</section>
<section id="submission-steps-10-pts" class="level2">
<h2 class="anchored" data-anchor-id="submission-steps-10-pts">Submission Steps (10 pts)</h2>
<ol type="1">
<li>This problem set is a paired problem set.</li>
<li>Play paper, scissors, rock to determine who goes first. Call that person <em>Partner 1</em>.
<ul>
<li>Partner 1 (name and cnet ID): Yuki Yan &amp; yukiyan</li>
<li>Partner 2 (name and cnet ID): Tianhao Zhang &amp; tz2205</li>
</ul></li>
<li>Partner 1 will accept the <code>ps4</code> and then share the link it creates with their partner. You can only share it with one partner so you will not be able to change it after your partner has accepted.</li>
<li>“This submission is our work alone and complies with the 30538 integrity policy.” Add your initials to indicate your agreement: **** ****</li>
<li>“I have uploaded the names of anyone else other than my partner and I worked with on the problem set <strong><a href="https://docs.google.com/forms/d/185usrCREQaUbvAXpWhChkjghdGgmAZXA3lPWpXLLsts/edit">here</a></strong>” (1 point)</li>
<li>Late coins used this pset: **\1_** Late coins left after submission: **\1_**</li>
<li>Knit your <code>ps4.qmd</code> to an PDF file to make <code>ps4.pdf</code>,
<ul>
<li>The PDF should not be more than 25 pages. Use <code>head()</code> and re-size figures when appropriate.</li>
</ul></li>
<li>(Partner 1): push <code>ps4.qmd</code> and <code>ps4.pdf</code> to your github repo.</li>
<li>(Partner 1): submit <code>ps4.pdf</code> via Gradescope. Add your partner on Gradescope.</li>
<li>(Partner 1): tag your submission in Gradescope</li>
</ol>
<p><strong>Important:</strong> Repositories are for tracking code. <strong>Do not commit the data or shapefiles to your repo.</strong> The best way to do this is with <code>.gitignore</code>, which we have covered in class. If you do accidentally commit the data, Github has a <a href="https://docs.github.com/en/repositories/working-with-files/managing-large-files/about-large-files-on-github#removing-files-from-a-repositorys-history">guide</a>. The best course of action depends on whether you have pushed yet. This also means that both partners will have to download the initial raw data and any data cleaning code will need to be re-run on both partners’ computers.</p>
</section>
<section id="download-and-explore-the-provider-of-services-pos-file-10-pts" class="level2">
<h2 class="anchored" data-anchor-id="download-and-explore-the-provider-of-services-pos-file-10-pts">Download and explore the Provider of Services (POS) file (10 pts)</h2>
<ol type="1">
<li><p>PRVDR_CTGRY_SBTYP_CD - Provider Category Subtype Code PRVDR_CTGRY_CD - Provider Category Code PRVDR_NUM - CMS Certification Number PGM_TRMNTN_CD - current termination status CITY_NAME - City where the facility is located STATE_CD - State code ZIP_CD - Zip code of the facility FAC_NAME - Facility name ST_ADR - Street address PRVDR_NUM - Provider Number</p></li>
<li><ol type="a">
<li></li>
</ol></li>
</ol>
<p>import pandas as pd import matplotlib.pyplot as plt</p>
<p>def load_and_filter_pos(file_path, year): pos_data = pd.read_csv(file_path, low_memory=False, encoding=‘latin1’)</p>
<pre><code>short_term_hospitals = pos_data[(pos_data['PRVDR_CTGRY_CD'] == 1) &amp; 
                                (pos_data['PRVDR_CTGRY_SBTYP_CD'] == 1)]

# Add column 
short_term_hospitals['Year'] = year
print(f"Year {year} - Number of short-term hospitals: {len(short_term_hospitals)}")  # Check the count
return short_term_hospitals</code></pre>
<p>pos2016 = load_and_filter_pos(‘pos2016.csv’, 2016) pos2017 = load_and_filter_pos(‘pos2017.csv’, 2017) pos2018 = load_and_filter_pos(‘pos2018.csv’, 2018) pos2019 = load_and_filter_pos(‘pos2019.csv’, 2019)</p>
<p>all_years_data = pd.concat([pos2016, pos2017, pos2018, pos2019], ignore_index=True)</p>
<p>observations_by_year = all_years_data[‘Year’].value_counts().sort_index()</p>
</section>
<section id="plot" class="level1">
<h1>Plot</h1>
<p>plt.figure(figsize=(10, 6)) observations_by_year.plot(kind=‘bar’) plt.title(‘Number of Short-Term Hospital Observations by Year’) plt.xlabel(‘Year’) plt.ylabel(‘Number of Observations’) plt.ylim(7240, 7305) plt.yticks(range(7240, 7306, 5))</p>
</section>
<section id="y-axis" class="level1">
<h1>y-axis</h1>
<p>plt.yticks(range(min(observations_by_year) - 10, max(observations_by_year) + 10, 10))</p>
<p>plt.xticks(rotation=0) plt.show()</p>
<pre><code>

4. 
    a.

```{python}
import pandas as pd
import matplotlib.pyplot as plt

unique_hospitals_by_year = all_years_data.groupby('Year')['PRVDR_NUM'].nunique()

# Plot the number of unique hospitals per year
plt.figure(figsize=(10, 6))
unique_hospitals_by_year.plot(kind='bar')
plt.title('Number of Unique Short-Term Hospitals by Year')
plt.xlabel('Year')
plt.ylabel('Number of Unique Hospitals')
plt.ylim(7240, 7305)  # Set a similar y-axis range for easy comparison
plt.xticks(rotation=0)
plt.show()

# Display the count for reference
print(unique_hospitals_by_year)
</code></pre>
<pre><code>b.
Each CMS certification number (PRVDR_NUM) appears only once per year. This indicates that the dataset is structured so that each hospital has a single, unique record in each year, without duplicate entries or multiple records reflecting different operational statuses or characteristics within the same year. Since there are no duplicates within each year, the dataset is reliable for examining trends over time, such as changes in the number of active short-term hospitals each year. The increase in counts from 2016 to 2019 reflects an actual trend rather than potential data artifacts caused by duplicated records.</code></pre>
<section id="identify-hospital-closures-in-pos-file-15-pts" class="level2">
<h2 class="anchored" data-anchor-id="identify-hospital-closures-in-pos-file-15-pts">Identify hospital closures in POS file (15 pts) (*)</h2>
<ol type="1">
<li></li>
</ol>
<pre class="{python}"><code>def load_and_filter_pos(file_path, year):
    pos_data = pd.read_csv(file_path, low_memory=False, encoding='latin1')
    pos_data['Year'] = year
    return pos_data

pos2016 = load_and_filter_pos('pos2016.csv', 2016)
pos2017 = load_and_filter_pos('pos2017.csv', 2017)
pos2018 = load_and_filter_pos('pos2018.csv', 2018)
pos2019 = load_and_filter_pos('pos2019.csv', 2019)
all_years_data = pd.concat([pos2016, pos2017, pos2018, pos2019], ignore_index=True)</code></pre>
<pre class="{python}"><code>pivoted_data = all_years_data.pivot_table(
    index=['PRVDR_NUM', 'FAC_NAME', 'ZIP_CD'], 
    columns='Year', 
    values='PGM_TRMNTN_CD', 
    aggfunc='first'
).reset_index()</code></pre>
<pre class="{python}"><code>pivoted_data['Suspected_Closure_Year'] = pivoted_data.apply(
    lambda row: next((year for year in [2017, 2018, 2019] if \
        (pd.isna(row[year]) or row[year] != 0) and row[2016] == 0), None), axis=1)
suspected_closures = pivoted_data.dropna(subset=['Suspected_Closure_Year'])</code></pre>
<pre class="{python}"><code>suspected_closures_list = suspected_closures[['FAC_NAME', 'ZIP_CD', 'Suspected_Closure_Year']]
total_suspected_closures = len(suspected_closures)
print(total_suspected_closures)</code></pre>
<p>15730 hospital fit this definition 2.</p>
<pre class="{python}"><code>sorted_suspected_closures = suspected_closures_list.sort_values(by='FAC_NAME')
sorted_suspected_closures.head(10)</code></pre>
<ol start="3" type="1">
<li><ol type="a">
<li></li>
</ol>
<pre class="{python}"><code>zip_year_counts = all_years_data[all_years_data['PGM_TRMNTN_CD'] == 0].groupby(['ZIP_CD', 'Year']).size()</code></pre>
<pre class="{python}"><code>suspected_closures['Is_Merger'] = suspected_closures.apply(
lambda row: (
    zip_year_counts.get((row['ZIP_CD'], row['Suspected_Closure_Year'] + 1), 0) &gt;= 
    zip_year_counts.get((row['ZIP_CD'], row['Suspected_Closure_Year']), 0)
) if row['Suspected_Closure_Year'] &lt; 2019 else False,
axis=1)

potential_mergers = suspected_closures[suspected_closures['Is_Merger']]
corrected_closures = suspected_closures[~suspected_closures['Is_Merger']]</code></pre>
<ol start="2" type="a">
<li></li>
</ol>
<pre class="{python}"><code>num_potential_mergers = len(potential_mergers)
num_corrected_closures = len(corrected_closures)
print("Number of hospitals identified as potential mergers:", num_potential_mergers)
print("Number of hospitals remaining after correction:", num_corrected_closures)</code></pre>
<ol start="3" type="a">
<li></li>
</ol>
<pre class="{python}"><code>corrected_closures_sorted = corrected_closures[['FAC_NAME', 'ZIP_CD', 'Suspected_Closure_Year']].sort_values(by='FAC_NAME')
corrected_closures_sorted.head(10)</code></pre></li>
</ol>
</section>
<section id="download-census-zip-code-shapefile-10-pt" class="level2">
<h2 class="anchored" data-anchor-id="download-census-zip-code-shapefile-10-pt">Download Census zip code shapefile (10 pt)</h2>
<ol type="1">
<li>The .shp is Shapefile, which contains the geometry (spatial features) of the shapes, such as points, lines, or polygons. This has 845.9 MB which is largest. The .shx (Shape Index File), which is an index file that allows for quick access to the geometry in the .shp file. It essentially points to the spatial features, making it faster to query the shapefile. It has 266kb. The .dbf (Database File) contains attribute data (tabular data) related to each shape, stored in dBase format. Attributes might include details like names, zip codes, or other metadata associated with each geographic feature. It has 6.4 MB. The .prj (Projection File) defines the coordinate system and map projection used in the shapefile. This has 4 KB. The .xml (Metadata File) contains metadata about the shapefile, such as data source, creation information, and attribute descriptions. It has 16 KB.</li>
<li></li>
</ol>
<pre class="{python}"><code>import os
from pyproj import datadir

os.environ["PROJ_LIB"] = "/opt/homebrew/Cellar/proj/9.5.0/share/proj"
os.environ["PROJ_DATA"] = "/opt/homebrew/Cellar/proj/9.5.0/share/proj"

datadir.set_data_dir("/opt/homebrew/Cellar/proj/9.5.0/share/proj")
import pyproj
print("PROJ data directory:", pyproj.datadir.get_data_dir())


import geopandas as gpd
import pandas as pd
import matplotlib.pyplot as plt

shapefile_path = "gz_2010_us_860_00_500k/gz_2010_us_860_00_500k.shp"
zipcodes = gpd.read_file(shapefile_path)
print("Shapefile loaded successfully!")

print("Columns in shapefile:", zipcodes.columns)

shapefile_path = "gz_2010_us_860_00_500k/gz_2010_us_860_00_500k.shp"
zipcodes = gpd.read_file(shapefile_path)
print("Columns in shapefile:", zipcodes.columns)

texas_zip_prefixes = ['75', '76', '77', '78', '79']
texas_zipcodes = zipcodes[zipcodes['ZCTA5'].str.startswith(tuple(texas_zip_prefixes))]

texas_zipcodes['ZCTA5'] = texas_zipcodes['ZCTA5'].astype(str)

pos2016 = pd.read_csv("pos2016.csv")

pos2016['ZIP_CD'] = pos2016['ZIP_CD'].astype(str)

hospital_counts = pos2016.groupby('ZIP_CD').size().reset_index(name='hospital_count')

texas_zipcodes = texas_zipcodes.merge(hospital_counts, left_on='ZCTA5', right_on='ZIP_CD', how='left')
texas_zipcodes['hospital_count'] = texas_zipcodes['hospital_count'].fillna(0)

fig, ax = plt.subplots(1, 1, figsize=(12, 10))
texas_zipcodes.plot(column='hospital_count', cmap='OrRd', linewidth=0.8, ax=ax, edgecolor='0.8', legend=True)
plt.title('Number of Hospitals by Zip Code in Texas (2016)')
plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.show()
</code></pre>
</section>
<section id="calculate-zip-codes-distance-to-the-nearest-hospital-20-pts" class="level2">
<h2 class="anchored" data-anchor-id="calculate-zip-codes-distance-to-the-nearest-hospital-20-pts">Calculate zip code’s distance to the nearest hospital (20 pts) (*)</h2>
<ol type="1">
<li></li>
</ol>
<pre class="{python}"><code># import sys
# sys.setrecursionlimit(200000) 

import geopandas as gpd
shapefile_path = 'gz_2010_us_860_00_500k/gz_2010_us_860_00_500k.shp'
zips_all = gpd.read_file(shapefile_path)</code></pre>
<pre class="{python}"><code>zips_all_centroids = zips_all.copy()
zips_all_centroids['centroid'] = zips_all.geometry.centroid
zips_all_centroids = zips_all_centroids.set_geometry('centroid')</code></pre>
<pre class="{python}"><code>print("Dimensions of the GeoDataFrame:", zips_all_centroids.shape)</code></pre>
<p>GEO_ID: A unique identifier for each area, formatted with a prefix (8600000US) plus the ZIP code. ZCTA5: The 5-digit ZIP Code Tabulation Area (ZCTA), a Census Bureau representation of a ZIP code area. NAME: The ZIP code associated with each ZCTA. LSAD: Indicates that each row is a 5-digit ZCTA. CENSUSAREA: The land area of the ZCTA in square miles. geometry: The shape of each ZCTA, as either: POLYGON: A single shape. MULTIPOLYGON: Multiple shapes, used if a ZIP code area is split into separate parts. 2.</p>
<pre class="{python}"><code>texas_zip_prefixes = ['75', '76', '77', '78', '79']  # Texas ZIP code prefixes
zips_texas_centroids = zips_all_centroids[zips_all_centroids['ZCTA5'].str.startswith(tuple(texas_zip_prefixes))]
unique_texas_zips = zips_texas_centroids['ZCTA5'].nunique()</code></pre>
<pre class="{python}"><code>from shapely.ops import unary_union

texas_polygon = unary_union(zips_texas_centroids.geometry).convex_hull
# making this multipolygon into a big polygon with convex_hull
def polygons_intersect_or_touch(polygon1, polygon2):
    return polygon1.intersects(polygon2) or polygon1.touches(polygon2)</code></pre>
<pre class="{python}"><code>zips_texas_borderstates_centroids = zips_all_centroids[zips_all_centroids.geometry.apply(lambda x: polygons_intersect_or_touch(texas_polygon, x))]

unique_texas_border_zips = zips_texas_borderstates_centroids['ZCTA5'].nunique()
print("Number of unique ZIP codes in Texas:", unique_texas_zips)
print("Number of unique ZIP codes in Texas and border states:", unique_texas_border_zips)</code></pre>
<ol start="3" type="1">
<li></li>
</ol>
<pre class="{python}"><code>zips_texas_borderstates_centroids['ZCTA5'] = pd.to_numeric(zips_texas_borderstates_centroids['ZCTA5'], errors='coerce')
pos2016['ZIP_CD'] = pd.to_numeric(pos2016['ZIP_CD'], errors='coerce')


hospital_zip_codes_2016 = pos2016[['ZIP_CD']].drop_duplicates()
zips_withhospital_centroids = zips_texas_borderstates_centroids.merge(
    hospital_zip_codes_2016,
    how='inner',
    left_on='ZCTA5',
    right_on='ZIP_CD'
)
unique_hospital_zips = zips_withhospital_centroids['ZCTA5'].nunique()
print("Number of unique ZIP codes in Texas and bordering states with at least one hospital in 2016:", unique_hospital_zips)</code></pre>
<p>Number of unique ZIP codes in Texas and bordering states with at least one hospital in 2016: 1292.</p>
<p>The merge function joins zips_texas_borderstates_centroids and hospital_zip_codes_2016:</p>
<p>how=‘inner’: An inner join keeps only the rows where ZCTA5 in zips_texas_borderstates_centroids matches ZIP_CD in hospital_zip_codes_2016.</p>
<p>left_on=‘ZCTA5’, right_on=‘ZIP_CD’: Specifies the columns to match on. 4.</p>
<pre class="{python}"><code>import time
from shapely.ops import nearest_points

subset_zips_texas_centroids = zips_texas_centroids.head(10)
def calculate_nearest_distance(row, target_gdf):
    nearest_geom = nearest_points(row.geometry, target_gdf.unary_union)[1]
    return row.geometry.distance(nearest_geom)

start_time = time.time()
subset_zips_texas_centroids['nearest_distance'] = subset_zips_texas_centroids.apply(
    calculate_nearest_distance, target_gdf=zips_withhospital_centroids, axis=1
)

elapsed_time = time.time() - start_time
print(f"Time taken for 10 ZIP codes: {elapsed_time:.2f} seconds")</code></pre>
<pre class="{python}"><code>total_rows = len(zips_texas_centroids)
estimated_time = (elapsed_time / 10) * total_rows
print(f"Estimated time for full dataset: {estimated_time / 60:.2f} minutes")</code></pre>
<pre><code>a.</code></pre>
<pre class="{python}"><code>start_time = time.time()

zips_texas_centroids['nearest_distance'] = zips_texas_centroids.apply(
calculate_nearest_distance, target_gdf=zips_withhospital_centroids, axis=1
)

full_elapsed_time = time.time() - start_time
print(f"Time taken for full dataset: {full_elapsed_time / 60:.2f} minutes")</code></pre>
<p>Estimated time for full dataset: 0.14 minutes Time taken for full dataset: 0.08 minutes They were quite off. b. The .prj file indicates that the coordinate system is GCS_North_American_1983, with units in degrees.</p>
<pre class="{python}"><code>zips_texas_centroids = zips_texas_centroids.to_crs("EPSG:5070")
zips_withhospital_centroids = zips_withhospital_centroids.to_crs("EPSG:5070")
zips_texas_centroids['nearest_distance_meters'] = zips_texas_centroids.apply(
    calculate_nearest_distance, target_gdf=zips_withhospital_centroids, axis=1
)
conversion_factor = 0.000621371  # 1 meter ≈ 0.000621371 miles
zips_texas_centroids['nearest_distance_miles'] = zips_texas_centroids['nearest_distance_meters'] * conversion_factor

average_distance_miles = zips_texas_centroids['nearest_distance_miles'].mean()</code></pre>
<ol start="5" type="1">
<li><ol type="a">
<li>In miles.</li>
<li></li>
</ol></li>
</ol>
<pre class="{python}"><code>print(f"Average distance to the nearest hospital for each ZIP code in Texas (in miles): {average_distance_miles:.2f}")</code></pre>
<pre><code>c.</code></pre>
<pre class="{python}"><code>import matplotlib.pyplot as plt

fig, ax = plt.subplots(1, 1, figsize=(10, 10))
zips_texas_centroids.plot(column='nearest_distance_miles', cmap='coolwarm', linewidth=0.8, ax=ax, edgecolor='0.8', legend=True)

ax.set_title("Distance to Nearest Hospital for Each ZIP Code in Texas (in miles)")
ax.set_axis_off()
plt.show()</code></pre>
<p>This makes sense, as ZIP codes closer to the U.S. border tend to have greater distances to the nearest hospital compared to those located further inland.</p>
</section>
<section id="effects-of-closures-on-access-in-texas-15-pts" class="level2">
<h2 class="anchored" data-anchor-id="effects-of-closures-on-access-in-texas-15-pts">Effects of closures on access in Texas (15 pts)</h2>
<ol type="1">
<li></li>
</ol>
<pre class="{python}"><code>texas_zip_prefixes = ['75', '76', '77', '78', '79']
corrected_closures['ZIP_CD'] = corrected_closures['ZIP_CD'].astype(str)

texas_closures = corrected_closures[corrected_closures['ZIP_CD'].str.startswith(tuple(texas_zip_prefixes))]

closure_counts = texas_closures.groupby('ZIP_CD').size().reset_index(name='closure_count')

closure_counts_sorted = closure_counts.sort_values(by='closure_count', ascending=False)

print("Texas Zip Codes and the Number of Hospital Closures (2016-2019):")
print(closure_counts_sorted)</code></pre>
<ol start="2" type="1">
<li></li>
</ol>
<pre class="{python}"><code>import os
import geopandas as gpd
import pandas as pd
import matplotlib.pyplot as plt
os.environ["PROJ_LIB"] = "/opt/homebrew/Cellar/proj/9.5.0/share/proj"

texas_zip_prefixes = ['75', '76', '77', '78', '79']
corrected_closures['ZIP_CD'] = corrected_closures['ZIP_CD'].astype(str).str.split('.').str[0].str.zfill(5)
corrected_closures_texas = corrected_closures[corrected_closures['ZIP_CD'].str[:2].isin(texas_zip_prefixes)]

closure_counts = corrected_closures_texas.groupby('ZIP_CD').size().reset_index(name='closure_count')

shapefile_path = "gz_2010_us_860_00_500k/gz_2010_us_860_00_500k.shp"
zipcodes = gpd.read_file(shapefile_path)
zipcodes['ZCTA5'] = zipcodes['ZCTA5'].astype(str).str.zfill(5)
texas_zipcodes = zipcodes[zipcodes['ZCTA5'].str[:2].isin(texas_zip_prefixes)]

texas_zipcodes = texas_zipcodes.merge(closure_counts, left_on='ZCTA5', right_on='ZIP_CD', how='left')
texas_zipcodes['closure_count'] = texas_zipcodes['closure_count'].fillna(0)

fig, ax = plt.subplots(1, 1, figsize=(12, 10))
texas_zipcodes.plot(column='closure_count', cmap='OrRd', linewidth=0.8, ax=ax, edgecolor='0.8', legend=True)
plt.title('Directly Affected Texas ZIP Codes by Hospital Closures (2016-2019)')
plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.show()

directly_affected_zipcodes = texas_zipcodes[texas_zipcodes['closure_count'] &gt; 0]
print("Number of directly affected Texas ZIP codes:", directly_affected_zipcodes.shape[0])</code></pre>
<ol start="3" type="1">
<li></li>
</ol>
<pre class="{python}"><code>import geopandas as gpd
from geopandas.tools import sjoin
import pandas as pd
import matplotlib.pyplot as plt

directly_affected_zipcodes_gdf = texas_zipcodes[texas_zipcodes['closure_count'] &gt; 0]

directly_affected_zipcodes_gdf = gpd.GeoDataFrame(directly_affected_zipcodes_gdf, geometry='geometry', crs="EPSG:4326")

directly_affected_zipcodes_gdf = directly_affected_zipcodes_gdf.to_crs(epsg=2163) 

buffered_zones = directly_affected_zipcodes_gdf.copy()
buffered_zones['geometry'] = directly_affected_zipcodes_gdf.geometry.buffer(16093)  # 10 miles in meters

texas_zipcodes_projected = texas_zipcodes.to_crs(epsg=2163)

indirectly_affected_zipcodes = sjoin(texas_zipcodes_projected, buffered_zones, how="inner", predicate="intersects")

print("Columns in indirectly_affected_zipcodes after spatial join:", indirectly_affected_zipcodes.columns)

if 'ZCTA5' in indirectly_affected_zipcodes.columns:
    column_name = 'ZCTA5'
else:
    column_name = indirectly_affected_zipcodes.columns[0]


indirectly_affected_zipcodes = indirectly_affected_zipcodes[
    ~indirectly_affected_zipcodes[column_name].isin(directly_affected_zipcodes_gdf['ZCTA5'])
]

num_indirectly_affected = indirectly_affected_zipcodes[column_name].nunique()
print("Number of indirectly affected Texas ZIP codes:", num_indirectly_affected)
</code></pre>
<ol start="4" type="1">
<li></li>
</ol>
<pre class="{python}"><code>import geopandas as gpd
import matplotlib.pyplot as plt

texas_zipcodes['impact_status'] = 'Unaffected'  # Default to unaffected
texas_zipcodes.loc[texas_zipcodes['ZCTA5'].isin(directly_affected_zipcodes_gdf['ZCTA5']), 'impact_status'] = 'Directly Affected'

texas_zipcodes.loc[texas_zipcodes['ZCTA5'].isin(indirectly_affected_zipcodes[column_name]), 'impact_status'] = 'Indirectly Affected'

fig, ax = plt.subplots(1, 1, figsize=(12, 10))
texas_zipcodes.plot(column='impact_status', cmap='coolwarm', linewidth=0.8, ax=ax, edgecolor='0.8', legend=True)

plt.title('Texas ZIP Codes Affected by Hospital Closures (2016-2019)')
plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.show()</code></pre>
</section>
<section id="reflecting-on-the-exercise-10-pts" class="level2">
<h2 class="anchored" data-anchor-id="reflecting-on-the-exercise-10-pts">Reflecting on the exercise (10 pts)</h2>
<ol type="1">
<li><p>Hospitals may close briefly for renovations or disasters, which the method might mistake as permanent closures. Mergers, ownership changes, or new CMS numbers could be falsely flagged as closures. There also might be data larges that there are delayed or incomplete updates that can misrepresent a facility’s status. I could think of an improvement that uses cross-reference with multiple sources, which verifies closures by checking other datasets like state health departments or news reports. We could also track service types for changing services instead of truly closer.</p></li>
<li><p>The current method is to determine the closure rate by checking whether the hospitals listed as “active” in 2016 remained active or disappeared in subsequent years. The method adjusts for closures due to mergers by deleting hospitals in postal code areas where the number of active hospitals has not decreased. However, if a hospital closes and reopens in a neighboring postal code area under a new certification, the method may misidentify the closure. Furthermore, the method does not take population size into account, so the handling of closures is the same in areas with high and low population density. Some improvements can be made, such as weighting closures based on the population affected by the postal code area to better understand their impact, or checking whether the hospital reopens in a neighboring postal code area within a shorter distance, which may indicate a hospital relocation rather than a true closure.</p></li>
</ol>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>